<html>
<head>
<title>Please Mind The Gap</title>
 <style>body { margin: 0; } canvas { width: 100%; height: 100% } </style>
</head> <body>

  <div id="blocker">

    <div id="instructions">
      <span style="font-size:40px">Click to play</span>
      <br />
      (W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
    </div>

  </div>


<script src="lib/three.min.js"></script>
<script type="text/javascript" src="lib/Physijs/physi.js"></script>
<script src="lib/ImprovedNoise.js"></script>
<script src="lib/PointerLock.js"></script>
<script>
Physijs.scripts.worker = 'lib/Physijs/physijs_worker.js';
Physijs.scripts.ammo = 'examples/js/ammo.js';


var verticalMovement, horizontalMovement;
var scene;

var camera, player, activeObject, activeObjectPicker;
var renderer;
var moveForward, moveBackward, moveLeft, moveRight;
var perlin;
var clock;

var boxgeom, boxmesh, boxmaterial, groundGeometry, ground, groundMaterial;
var directionalLight;
var activeMaterial;
var artefacts = [];

//-----------------------------------------------------------
var normalCameraHeight = 2;
var normalPlayerPosition = normalCameraHeight/2;
//-----------------------------------------------------------

/*
TODO: Draw orientation bubble in the middle

*/

document.addEventListener( 'mousemove', onDocumentMouseMove, false );
document.addEventListener( 'mousedown', onDocumentMouseDown, false );

document.addEventListener( 'keydown', onKeyDown, false );
document.addEventListener( 'keyup', onKeyUp, false );

function init(){
  console.log("init...");
  perlin = new ImprovedNoise();

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);

  renderer.shadowMapEnabled = false;
  renderer.shadowMapSoft = false;

  renderer.shadowCameraNear = 3;
  renderer.shadowCameraFar = 200;
  renderer.shadowCameraFov = 50;

  renderer.shadowMapBias = 0.0039;
  renderer.shadowMapDarkness = 0.5;
  renderer.shadowMapWidth = 1024;
  renderer.shadowMapHeight = 1024;
  document.body.appendChild(renderer.domElement);

  scene = new Physijs.Scene;
  scene.setGravity(new THREE.Vector3( 0, -5, 0 ));
  
  directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
  directionalLight.position.set( 0, 1, 0 ); scene.add( directionalLight );
  directionalLight.rotation.set(0.1, 0.2, 0.3);

  player = new Physijs.BoxMesh( new THREE.CubeGeometry(2, 2, normalCameraHeight, 8 ), new THREE.MeshBasicMaterial({ color: 0x888888 }) );
  player.visible = false;
  player.userData.category = "player";
  player.addEventListener( 'collision', collision);
  player.position.y = normalPlayerPosition;


  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.2, 200);
  camera.rotation.order = "YXZ"; // necessary to get proper camera rotation
  camera.position.set(0, normalCameraHeight, 0);


  player.add( camera );
  scene.add( player );
  
  // set angular factor to 0,0,0 to prevent tripping over of player
  player.setAngularFactor(new THREE.Vector3(0,0,0));

  activeObjectPicker = new THREE.Raycaster(player.position, camera.getWorldDirection());
  activeMaterial = new THREE.MeshBasicMaterial({ color: 0xbc1a49 });

  boxgeom = new THREE.BoxGeometry( 2, 2, 2 );
  boxmaterial = new THREE.MeshLambertMaterial({
    ambient:0xee7b09,
    color: 0x6adeb5,
    specular: 0x009900,
    shininess: 10
  });



  groundGeometry = new THREE.BoxGeometry( 200, 1, 200 );
  groundMaterial = new THREE.MeshLambertMaterial( {color: 0xacaaaa, side: THREE.SingleSided} );
  ground = new Physijs.BoxMesh(
    groundGeometry,
    groundMaterial,
    0 // mass
  );
  ground.receiveShadow = false;
  ground.position.y = -10;
  ground.userData.category = "ground";
  ground.addEventListener( 'collision', collision);
  scene.add( ground );

  createPlatform();


  clock = new THREE.Clock(true);
  clock.start();
  requestAnimationFrame(render);
}

function mutateObject(){
}


// this is our draw loop. executed 60 times per second
function render(){
  createRandomFallingObject(5);
  activeObjectPicker.set(player.position, camera.getWorldDirection());
  makeSteps();
  scene.simulate();
  requestAnimationFrame(render);
  renderer.render(scene, camera);
}

function look(){
  camera.rotation.x -= horizontalMovement * 0.002;
  camera.rotation.y -= verticalMovement * 0.002;

  // create raytracer and get active object
  // (later when clicking on active object define action depending on category (blue, green, ...))
  //console.log(activeObjectPicker.ray.origin);

  var intersections = activeObjectPicker.intersectObjects(artefacts, false);
  var intersects = intersections.length > 0; // set to true of intersection exist
  var activeChanged = false;

  // set boolean when either there is now an active object  OR not anymore OR if the active object is a new one
  if ((activeObject === undefined && intersects) || (activeObject !== undefined && intersects === false) ||
    intersects && ( intersections[0].object.id !==  activeObject.id )){

         activeChanged = true;

       }
// TODO: merge with previous if ^   ?
  if( activeChanged ) {
    // reset previous activeObjects material (state?)
    if (activeObject !== undefined) activeObject.material = boxmaterial;

    // set new active object and material if any new
    if( intersects ) {
      activeObject = intersections[0].object;
      activeObject.material = activeMaterial;
    } else {
      activeObject = undefined;
    }
  }


}

function jump(){
  player.applyCentralImpulse(new THREE.Vector3(0, 50, 0));

}

function makeSteps(){
  if(!moveForward && !moveBackward && !moveLeft && !moveRight){
    // walking ended? -> reset walking height to standard, (only camera movement)
    if(camera.position.y > normalCameraHeight + 0.1)
      camera.position.y -= (THREE.Math.smoothstep(camera.position.y, normalCameraHeight, normalCameraHeight + 2));
      camera.__dirtyPosition = true;
      player.__dirtyPosition = true;
    return;
  } // return if not moved

   // simulate walking with two legs by perlin noise
   // this should be for now only applied to the cam, to avoid falling
   var roughness = new THREE.Vector3(0,0,0);
   var noiseX = perlin.noise( (clock.getElapsedTime() + 123456) * 5, 0, 0) / 40;
   var noiseY = perlin.noise( (clock.getElapsedTime() + 7777777) * 5, 0, 0) / 70;

   roughness.y = (Math.sin(clock.getElapsedTime()*10) / 50) + noiseY;
   roughness.x = (Math.cos(clock.getElapsedTime()*10) / 130) + noiseX;
   camera.position.add(roughness);

  // get normalized looking direction of camera
  // to move player in that direction
  // thanks! -> http://stackoverflow.com/questions/14813902/three-js-get-the-direction-in-which-the-camera-is-looking
  var vector = new THREE.Vector3( 0, 0, -1 );
  vector.applyQuaternion( camera.quaternion );
  //since threejs rev69:  var vector = camera.getWorldDirection();

  vector.y = 0; // we don't want to move vertical, aka climbing a ladder
  vector.divideScalar( 15 );
  if( moveForward ) player.position.add(vector);
  if( moveBackward ) player.position.sub(vector);

  if( moveLeft || moveRight ){
    vector.cross( new THREE.Vector3( 0, 1, 0 ));
    if( moveRight ) player.position.add(vector);
    if( moveLeft ) player.position.sub(vector);
  }

  player.__dirtyPosition = true;
  camera.__dirtyPosition = true;

}

function onDocumentMouseDown( event ) {
console.log("mousedown");
  if(activeObject !== undefined){
    activeObject.applyCentralImpulse(new THREE.Vector3(0, 10, 0));
    if(activeObject.userData.category === "green"){
      // action green
    } else if(activeObject.userData.category === "blue"){
      // action blue
    } else if(activeObject.userData.category === "red"){
    }

  } else {

    // mousedown without active object

    createObjectAtSight();
  }


}

function onDocumentMouseMove( event ) {

  //TODO: look at some stuff done in: http://threejs.org/examples/js/controls/FirstPersonControls.js
  event.preventDefault();
  // vertical and horizontal movement seems counter intuitive but it is the axes
  // you are rotating along
  verticalMovement = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
  horizontalMovement = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

  look();
}

function createRandomObject(pos){
  // basesize, color with random variations please
  var boxGeometry = new THREE.BoxGeometry(  2,2,2 );
  var randomMesh = new Physijs.BoxMesh( boxGeometry, boxmaterial, 1 );

  randomMesh.position.copy(pos);
  randomMesh.castShadow = false;
  randomMesh.receiveShadow = false;
  randomMesh.userData.category = "generic random box";
  

  return randomMesh;
}


function createObjectAtSight(){

  var targetVector = new THREE.Vector3();
  targetVector.copy(camera.position);
  targetVector.add(camera.getWorldDirection().multiplyScalar(10));
  // now randomize coordinates in spherical boundary

  var newBox = createRandomObject(targetVector);
  // Enable CCD if the object moves more than 1 meter in one simulation frame
  newBox.setCcdMotionThreshold(1);
  
  // Set the radius of the embedded sphere such that it is smaller than the object
  newBox.setCcdSweptSphereRadius(0.2);


  artefacts.push( newBox );
  scene.add( newBox );
}

function createRandomFallingObject(heigth_){
  if(Math.random() * 300 < 1){
    var targetVector = new THREE.Vector3((Math.random() * 20) - 10, heigth_, (Math.random() * 20) - 10);
    var randomObject = createRandomObject(targetVector);
    randomObject.rotation.x = Math.random();
    randomObject.rotation.y = Math.random();
    randomObject.rotation.z = Math.random();
    
    // Enable CCD if the object moves more than 1 meter in one simulation frame
    randomObject.setCcdMotionThreshold(1);
    
    // Set the radius of the embedded sphere such that it is smaller than the object
    randomObject.setCcdSweptSphereRadius(0.2);
    
    artefacts.push( randomObject );
    scene.add( randomObject );
    
  }
}


function removePlatformsInShadow(){
  var targetVector = new THREE.Vector3();
  targetVector.copy(camera.position);
  targetVector.add(camera.getWorldDirection().multiplyScalar(10));
  // iterate array of added artefacts and randomly delete those with destination < 5
  // with higher probability the smaller the destination
  for (var i = 0; i < artefacts.length; i++) {
    var dest = targetVector.dest(artefacts[i]);
  }
}

function collision( other_object, relative_velocity, relative_rotation, contact_normal ){
  console.log("collision...");
  //console.log(this.userData.category + "collision detected. with: " + other_object.userData.category);
  
  /*if(this.userData.category == "ground" && other_object.userData.category != "player"){
    console.log("hit ground. remove it.");
    scene.remove(other_object);
    other_object.geometry.dispose();
  }*/

}

function createPlatform(){
  var geometry = new THREE.BoxGeometry(2, 1, 2);
  var margin = 1;
  
  // generate a field of boxes
  for ( var z = 0; z < 15; z+=2 ) {
    for ( var x = 0; x < 15; x+=2 ) {
      var platformElement = new Physijs.BoxMesh( geometry, boxmaterial );
      platformElement.position.set( x + margin, (normalPlayerPosition - 2) + THREE.Math.randFloat(-0.3, 0.3), z + margin );
      platformElement.userData.category = "platform";
      artefacts.push(platformElement);

      scene.add(platformElement);    
      
      // 
      //FIXME: makes problem with collision callbacks for whole scene????
      //
      platformElement.setAngularFactor(new THREE.Vector3(0,0,0));
      platformElement.setLinearFactor(new THREE.Vector3(0,0,0));
      
    }
  }
}




function onKeyDown ( event ) {
  //via: http://threejs.org/examples/js/controls/FirstPersonControls.js
  //event.preventDefault();

  switch ( event.keyCode ) {

    case 38: /*up*/
    case 87: /*W*/ moveForward = true; break;

    case 37: /*left*/
    case 65: /*A*/ moveLeft = true; break;

    case 40: /*down*/
    case 83: /*S*/ moveBackward = true; break;

    case 39: /*right*/
    case 68: /*D*/ moveRight = true; break;

    case 32:  /* SPACE */ jump(); break;
  }
};

function onKeyUp ( event ) {
  //via: http://threejs.org/examples/js/controls/FirstPersonControls.js
  switch( event.keyCode ) {

    case 38: /*up*/
    case 87: /*W*/ moveForward = false; break;

    case 37: /*left*/
    case 65: /*A*/ moveLeft = false; break;

    case 40: /*down*/
    case 83: /*S*/ moveBackward = false; break;

    case 39: /*right*/
    case 68: /*D*/ moveRight = false; break;

  }

};

window.onload = init;

</script>
</body> </html>
